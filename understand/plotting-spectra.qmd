---
title: "Plotting size spectra"
---

In this worksheet you will take observational data and plot the resulting size spectra for the community and for individual species. This will give you a concrete understanding of what size spectra are.

We will be making use of the [tidyverse](https://www.tidyverse.org/) package, in particular [dplyr](https://dplyr.tidyverse.org/) and [ggplot2](https://ggplot2.tidyverse.org/) If you are not familiar with these, you can learn what is needed just by studying the example code in this worksheet. You will find explanations of the code if you expand the "R details" sections that you find below many of the code chunks. To expand an explanation section, just click on the "R details".

```{r message=FALSE}
library(tidyverse)
```

## The data

First we load the data.

```{r }
data <- readRDS("size-data.rds")
str(data)
```

:::{.callout-note collapse="true"}
### Expand for R details

The `readRDS()` function loads the file "size-data.rds" which contains the data frame with the size data. We assign this data frame to the variable `data` for use below and then, to get an impression of what is in the data frame we use the `str()` function.

You can always easily read more information about the functions we are using by clicking on the function name. This will open the function's help page in your browser.

:::

The data consists of measurements of the length in centimetres of `r nrow(data)` fish of various species. The species included are

```{r}
unique(data$species)
```

This data was assembled by Ken Andersen at DTU Aqua in Copenhagen. The `length` in centimetres $l$ was converted to `weight` in grams $w$ using the standard allometric relationship

$$ w = a\, l ^ b,$$

where the coefficient $a$ and the exponent $b$ are species-specific parameters (we'll discuss how to find such species parameters in a [later tutorial](../build/species-parameters.qmd)). The reason we like to work with weight as the measure of a fish's size is that there are well-known allometric relationships between weight and physiological rates. For example metabolic rate is often taken to scale as $w^{3/4}$ and mortality is taken to scale as $w^{-1/4}$.

:::{.callout-important}
When not otherwise specified, all lengths are given in centimetres [cm] and all weights are given in grams [g].
:::

## Weight histogram

To get an impression of the size distribution of the fish, we plot a histogram of the fish weights.

```{r message=FALSE}
(p <- ggplot(data) +
    geom_histogram(aes(weight), fill = "blue", colour = "black") +
    labs(x = "Weight [g]",
         y = "Number of fish"))
```

:::{.callout-note collapse="true"}
### Expand for R details

We have used the [ggplot2](https://ggplot2.tidyverse.org/) package, included in the tidyverse package, to make the plot. It is much more powerful and convenient than the base plot commands. It implements the "grammar of graphics". If you are not already using ggplot2 it is worth your time to familiarise yourself with it. However for the purpose of this tutorial, you can simply pick up the syntax from the examples we give.

In the above we first specify with `ggplot(data)` that the graph shall be based on the data frame `data` that we loaded previously. We then add features to the graph with the `+`.

First `geom_histogram()` specifies that we want a histogram plot. The argument specifies the variable to be represented. Note how this is wrapped in a call to `aes()`. Don't ask why, that is the way the grammar of graphics likes it. The specification of how the variables are tied to the aesthetics of the graph will always be given withing the `aes()` function.

We then specify that we want the bars in the histogram to be blue (`fill = "blue"`) with a black border (`colour = "black"`). Such tuning of the appearance is of course totally optional. By the way: one has to admire how the ggplot2 package accepts both `colour` and `colour`, so that our US friends can use `color = "black`.

Then we add our own labels to the axes with `labs()`.

We assign the resulting plot to the variable `p` because that way we can manipulate the plot further below. Because the assignment operator in R does not display any result, we added another line with just the variable name `p` which will display the plot.

:::

The plot is not very informative. It just tells us that most fish are very small but there is a small number of very large fish. We can not see much detail. The first way to improve the plot is to plot the y-axis on a logarithmic scale. That has the effect of stretching out the small values and squashing the large values, revealing more detail.

```{r message=FALSE}
p + scale_y_log10()
```

We get a warning because there were bins that contained no fish, and taking the log of 0 is not allowed. We can ignore these warnings because the empty bins will simply not be given a bar in the resulting plot.

The second way to deal with the fact that there are so many more small fish than large fish, is to make the bin width larger at larger sizes and smaller at smaller sizes. For example we could make the smallest bin go from 1 gram to 2 gram, the next bin to go from 2 gram to 4 gram, and so on, with each next bin twice the size of the previous. Let's create the break points between these bins:

```{r }
log_max <- log2(max(data$weight)) + 1
(log_breaks <- seq(from = 0, to = log_max, by = 1))

(breaks <- 2 ^ log_breaks)
```

:::{.callout-note collapse="true"}
### Expand for R details

We had decided that we wanted the breaks between the bins to be at powers of 2. We first create the vector `log_breaks` with the exponents. The `seq()` function creates a vector of numbers starting at `from` and going up to `to` in steps of size `by`. You do not need to give the names of the arguments because they can also be identified by their position. So you could also have written `seq(0, log_max, 1)`. Such integer sequences are used so often that there is the even shorter notation `0:log_max` giving the same sequence.

Note how R is good at vectorised calculations. The second line above creates a vector containing the powers of 2 with the exponents taken from the entries of the vector `log_breaks`.

The reason we have put parentheses `( ... )` around the assignments in the above code is because that also leads to the result being displayed whereas the assignment operator without those parentheses around it would not display anything.

:::

Now we can use these logarithmically spaced bins in the histogram:

```{r message=FALSE}
ggplot(data) +
    geom_histogram(aes(weight), fill = "blue", colour = "black",
                   breaks = breaks) +
    labs(x = "Weight [g]",
         y = "Number of fish") +
    scale_y_log10()
```

The heights are now slightly more even among the bins.

Note that the height of the bars changed as we changed how we bin the data. That is obvious. If we make a bin twice as large, we expect twice as many fish in that bin. To get rid of this dependence on the choice of the width of bins, we want to work with the density. This is obtained by dividing the height of each bar by its width.

Because it is important to understand this concept of number density and biomass density, we calculate them by hand below, even though ggplot has a built-in function `geom_density()` that we could use instead. We first bin the data by hand, and then we calculate and plot the densities.

## Binning

To understand better what the histogram did and to improve the plots further, we bin the data ourselves. We do this by first adding a bin number to each observation, which gives the number of the bin in which the weight of the fish lies.

```{r }
binned <- data |>
    mutate(bin = cut(weight, breaks = breaks, right = FALSE,
                     labels = FALSE))
head(binned)
```

:::{.callout-note collapse="true"}
### Expand for R details

We used the pipe operator `|>` that simply pipes the output of the code preceeding it into the first argument of the function following it. So the above code is equivalent to

```{r eval=FALSE}
binned <- mutate(data, bin = cut(weight, breaks = breaks, right = FALSE,
                                 labels = FALSE))
```

The pipe operator becomes really useful only if you do a longer sequence of operations on data. You will see examples of its use later.

The `mutate()` function can add new columns to a data frame or modify existing columns. In the above example it adds a new column `bin`. The entries in that column are here calculated by the function `cut` that returns the label of the bin into which an observation falls. We specify the bin boundaries with the `breaks = breaks` to be the boundaries we have calculated above. The `right = FALSE` means that in case an observation falls exactly on a right bin boundary, it is not included in that bin but instead in the next bin. The `labels = FALSE` means that the bins are not labelled by the intervals but simply by integer codes.

:::

We then group the data by bin and calculate the number of fish as well as the biomass in each bin

```{r }
binned <- binned |> 
    group_by(bin) |> 
    summarise(Numbers = n(), 
              Biomass = sum(weight))
binned
```

:::{.callout-note collapse="true"}
### Expand for R details

After we have grouped together all the observations with the same bin number with the `group_by(bin)`, the `summarize()` function creates a new data frame with one row for each group, which in this case means one row for each bin. That data frame will always have one column specifying the group and then we specified that we want two extra columns: `Numbers` that just counts the number of observations in the group with the `n()` function and `Biomass` that calculates the total biomass in the group by summing the weights of all the fish in that group. Note that the `species` is ignored in this calculation.

In the above code you see the pipe operator `|>` being quite convenient, because it allows us to write the functions in the order in which they are applied, rather than having to write `summarize(group_by(...))`.

:::

The numbers in each bin give us the heights of the histogram above.

## Densities

The values for `Numbers` and `Biomass` of course depend on the size of bins we have chosen. It is therefore convenient to divide these numbers by their bin widths to get the corresponding densities. We get the number density as a function of weight by dividing the number of fish in each bin by the bin width. Similarly we get the biomass density as a function of weight by dividing the biomass in each bin by the bin width.

```{r}
bin_width <- diff(breaks)

binned <- binned |> 
    mutate(Number_dens = Numbers / bin_width[bin],
           Biomass_dens = Biomass / bin_width[bin])
```

:::{.callout-note collapse="true"}
### Expand for R details

We first calculate the widths of the bins using the `diff()` function which calculates the difference between neighbouring entries in a vector. Then when we calculate the entries for the new `Number_dens` and `Biomass_dens` columns we pick out the bin width appropriate to the given bin for each observation.

:::

## Number density
Let's make a plot of the number density against weight. Of course we don't know the number density for all weights because we discretised the continuous weight variable into bins. We only have an average value for the number density in each bin, which we use to determine the height of the curve at the midpoint of the bin. The plot interpolates between these discrete points by straight lines to produce a continuous curve.

```{r warning=FALSE}
mid_points <- 2 ^ (log_breaks + 1/2)

ggplot(binned) +
    geom_line(aes(x = mid_points[bin], y = Number_dens)) +
    labs(x = "Weight [g]",
         y = "Number density")
```

Again the graph tells us that most of the individuals are very small, but we can not see any of the details. We therefore plot the density on log-log axes:

```{r warning=FALSE}
ggplot(binned) +
    geom_line(aes(x = mid_points[bin], y = Number_dens)) + 
    scale_x_log10() + 
    scale_y_log10() +
    labs(x = "Weight [g]",
         y = "Number density")
```

## Fitting a power law

Now we can see that the number density in this log-log plot is described approximately by a straight line. We can approximate the slope and intercept of that straight line by fitting a linear model

```{r}
(model <- lm(log(Number_dens) ~ log(mid_points[bin]), data = binned))
```

This tells us that the straight-line approximation has a slope of about `r signif(model$coefficients[[2]], 3)`. We can also ask ggplot to put this line, together with its 5% confidence interval:

```{r warning=FALSE}
ggplot(binned, aes(x = mid_points[bin], y = Number_dens)) +
    geom_line() + 
    scale_x_log10() + 
    scale_y_log10() +
    labs(x = "Weight [g]",
         y = "Number density") + 
    geom_smooth(method='lm')
```

:::{.callout-note collapse="true"}
### Expand for R details

The linear regression line is produced by `geom_smooth(method='lm')`. Not how we moved the call to `aes()` into the call to `ggplot()`. That is then used automatically for both the `geom_line()` and the `geom_smooth()`, so that we did not have to specify the information twice.
:::

If we denote the number density at weight $w$ by $N(w)$, then the above tells us that $$\log(N(w)) \approx `r signif(model$coefficients[[1]], 3)` + \log(w)^{`r signif(model$coefficients[[2]], 3)`}.$$

If we exponentiate both sides to get rid of the logarithms this gives

$$ N(w) \approx \exp(`r signif(model$coefficients[[1]], 3)`) w^{`r signif(model$coefficients[[2]], 3)`} = N(1) w^{-\lambda} $$
with $\lambda \approx `r signif(model$coefficients[[2]], 3)`$.

:::{.callout-important}
A straight line on a log-log plot indicates a power-law relationship between the variables with the slope of the line being the exponent in the power law.
:::

Of course the approach we took above of estimating the exponent in the power law from the binned data is not ideal. If one has access to unbinned data, as we have here, one should always use that unbinned data for inference. So the better to infer the exponent from our data would be to ask: "If we randomly sampled individuals from the population described by the power law, for which exponent would our observations be the most likely". In other words, we should do a maximum likelihood estimation of the exponent.

```{r}
w_min = min(data$weight)
lambda <- 1 + nrow(data) / sum(log(data$weight / w_min))
lambda
```

:::{.callout-note collapse="true"}
### Expand for mathematical details

The linear regression line is produced by `geom_smooth(method='lm')`. Not how we moved the call to `aes()` into the call to `ggplot()`. That is then used automatically for both the `geom_line()` and the `geom_smooth()`, so that we did not have to specify the information twice.
:::

So this approach, which gives equal weight to each observation rather than giving equal weight to each bin, gives a lower value for $\lambda$, namely $\lambda \approx 1.71$ instead of $\lambda \approx 2.24$. But this is still not the end of the story, because we did not take measurement error into account. We assumed that we sample perfectly in proportion of the density. But in reality, small individuals are much easier to miss than large ones, so our data is almost certainly under-reporting the number of small individuals, which leads to a smaller $\lambda$. 

A good approach is to try to observe the power law over a wider range of sizes, all the way from bacteria to whales. This is what Sheldon et.al. did in 1972 and he observed that $\lambda \approx 2$. More thorough investigations since then have led to values just slightly above $2$ on average. TODO: references.

## Biomass density
We can plot the biomass density similarly

```{r }
ggplot(binned, aes(x = mid_points[bin], y = Biomass_dens)) +
    geom_line() + 
    scale_x_log10() + 
    scale_y_log10() +
    labs(x = "Weight [g]",
         y = "Number density") + 
    geom_smooth(method='lm') +
    geom_density(data = data, aes(weight, stat(count)), adjust = 4) 
```

Fitting a linear model to the binned biomass data gives

```{r}
(model <- lm(log(Biomass_dens) ~ log(mid_points[bin]), data = binned))
```

The slope is $-1.265$ for the biomass density whereas it was $-2.241$ for the number density. This makes perfect sense, because if we denote the biomass density by $B(w)$ then $B(w) = w N(w)$ and hence if $N(w) \propto w^{-\lambda}$ then $B(w)\propto w^{1-\lambda}$.


## Density in log weight

There is still a weakness in the way we visualised the size spectrum via the number density or the biomass density plotted on logarithmic axes.

Above we calculated densities by dividing the total number or total biomass in each bin by the width that the bin has on the $w$ axis. That is fine. But then we decided to use a logarithmic axis that showed $\log(w)$. But then would it not have been more natural to calculate the densities by dividing by the width of the bin on that logarithmic axis? 

Well, the answer to that is probably a matter of taste. Different people make a different choice. It is very important to be aware of this to understand discrepancies between reported power-law exponents: they depend on the choice made.

The result of dividing the total biomass in each bin by the width of the bin on the logarithmic weight axis is sometimes called the Sheldon spectrum, because it is this density that is approximately constant. Below we plot the Biomass density (in black) and the Sheldon density (in blue) on the same axes.
```{r }
log_bin_width <- diff(log_breaks)

binned <- binned |> 
    mutate(Sheldon_dens = Biomass / log_bin_width[bin])

ggplot(binned) +
    geom_line(aes(x = mid_points[bin], y = Biomass_dens),
              colour = "black") +
    geom_line(aes(x = mid_points[bin], y = Sheldon_dens),
              colour = "blue") +
    scale_x_log10() +
    scale_y_log10() +
    labs(x = "Log Weight",
         y = "Density")
```

We will refer to Sheldon's density as "the biomass density in log weight" and notate it as $B_{\log w}(w)$. Similarly we introduce "the number density in log weight" $N_{\log w}(w)$.

You will notice the reduced slope. In fact the slope of the Sheldon density is less negative than the slope of the biomass density. We have the following relations among the various densities:

$$B_{\log w}(w) = w\, B(w) = w\, N_{\log}(w) = w^2 N(w).$$

Sheldon's observation was that $B_{\log w}(w)$ is approximately constant over a large range of sizes $w$ from bacteria to whales. That corresponds to the earlier phrasing of Sheldon's observation that $N(w)\propto w^{-\lambda}$ with $\lambda$ close to 2.


## Kernel density estimate

Binning the data is not the only way to approximate the densities. One can also use the kernel density estimation method. ggplot2 even has that built in to its `geom_density()`. Here is a plot of the number density in log weight estimated by the kernel density method:

```{r}
ggplot(data) +
    geom_density(aes(weight, stat(count)), adjust = 4) +
    scale_x_log10() + 
    scale_y_log10() +
    labs(x = "Weight [g]",
         y = "Number density in log w")
```

## Species spectra

```{r}
p <- ggplot(data) +
    geom_density(aes(weight, stat(count), colour = species), adjust = 4) +
    geom_density(aes(weight, stat(count)), colour = "black", adjust = 4) +
    scale_x_continuous(trans = "log10") +
    scale_y_continuous(trans = "log10", limits = c(1, NA)) +
    labs(x = "Weight [g]",
         y = "Number density in log w")
plotly::ggplotly(p)
```